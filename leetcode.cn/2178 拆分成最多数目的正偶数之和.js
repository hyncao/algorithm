// 2178. 拆分成最多数目的正偶数之和

// 给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。

// 比方说，给你 finalSum = 12 ，那么这些拆分是 符合要求 的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意 finalSum 不能拆分成 (2 + 2 + 4 + 4) ，因为拆分出来的整数必须互不相同。
// 请你返回一个整数数组，表示将整数拆分成 最多 数目的正偶数数组。如果没有办法将 finalSum 进行拆分，请你返回一个 空 数组。你可以按 任意 顺序返回这些整数。

// 输入：finalSum = 12
// 输出：[2,4,6]
// 解释：以下是一些符合要求的拆分：(2 + 10)，(2 + 4 + 6) 和 (4 + 8) 。
// (2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。
// [2,6,4] ，[6,2,4] 等等也都是可行的解。

// 输入：finalSum = 7
// 输出：[]
// 解释：没有办法将 finalSum 进行拆分。
// 所以返回空数组。

// 输入：finalSum = 28
// 输出：[6,8,2,12]

// 反证法证明贪心方法是正确的。

// 用我们的方法找到的一个答案2 + 4 + ... + 2n + k = finalsum，即最多可以分成n + 1个数。 由于k不可继续划分，这意味着2n < k < (2n + 2) + (2n + 4) = 4n + 6。

// 假设不使用2~2n中的某个数2x之后，可以将finalsum分成更多的偶数，这意味着 k + 2x可以分成3个大于2n的数。 即k + 2x >= (2n + 2) + (2n + 4) + (2n + 6) = 6n + 12，即k + 2x >= 6n + 12。

// 由于k < 4n + 6，且2x <= 2n，既有k + 2x < 6n + 6。这与假设矛盾，即不存在这样的数2x。

// O(根号n) O(1)
// 执行用时：
// 292 ms, 在所有 JavaScript 提交中击败了 37.84% 的用户
// 内存消耗：
// 74 MB, 在所有 JavaScript 提交中击败了 43.24% 的用户
const maximumEvenSplit = finalSum => {
  if ((finalSum & 1) === 1) return [];
  const res = [];
  for (let i = 2; i <= finalSum; i += 2) {
    res.push(i);
    finalSum -= i;
  }
  res[res.length - 1] += finalSum;
  return res;
};

const finalSum = 28;

console.log(maximumEvenSplit(finalSum));
