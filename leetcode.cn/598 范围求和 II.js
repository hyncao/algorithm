// 598. 范围求和 II

// 给你一个 m x n 的矩阵 M ，初始化时所有的 0 和一个操作数组 op ，其中 ops[i] = [ai, bi] 意味着当所有的 0 <= x < ai 和 0 <= y < bi 时， M[x][y] 应该加 1。

// 在 执行完所有操作后 ，计算并返回 矩阵中最大整数的个数 。

// 输入: m = 3, n = 3，ops = [[2,2],[3,3]]
// 输出: 4
// 解释: M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。

// 输入: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
// 输出: 4

// 输入: m = 3, n = 3, ops = []
// 输出: 9

// 每一次操作，都是从矩阵的左上角开始的
// 执行用时：
// 56 ms, 在所有 JavaScript 提交中击败了 94.29% 的用户
// 内存消耗：
// 43.2 MB, 在所有 JavaScript 提交中击败了 20.95% 的用户
const maxCount = (m, n, ops) => {
  for (const i of ops) {
    m = Math.min(m, i[0]);
    n = Math.min(n, i[1]);
  }
  return m * n;
};

// 预期：6
const m = 26,
  n = 17,
  ops = [[2, 3]];

console.log(maxCount(m, n, ops));
