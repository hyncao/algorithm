// 1186. 删除一次得到子数组最大和

// 给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。

// 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。

// 注意，删除一个元素后，子数组 不能为空。

// 输入：arr = [1,-2,0,3]
// 输出：4
// 解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。

// 输入：arr = [1,-2,-2,3]
// 输出：3
// 解释：我们直接选出 [3]，这就是最大和。

// 输入：arr = [-1,-1,-1,-1]
// 输出：-1

// 思考：
// 截止 2023-06-28 最难的 dp 题
// 因为子数组的要求，所以原数组不能排序
// 非负数越多越好
// 期望删除的数一定是子数组中最小的

// 删除0个
// 如果dp[n-1][0] 为复数，则舍弃前面，加上arr[n]
// 如果dp[n-1][0] 为正数，则将arr[n]拼在后面
// dp[n][0] = Math.max(dp[n-1][0], 0) + arr[n]

// 删除1个
// 如果dp[n-1]已经删除了一个，即dp[n-1][1] + arr[n]
// 如果dp[n-1]没有删除，那么就删除 arr[n]
// dp[n][1] = Math.max(dp[n-1][1] + arr[n], dp[n-1][0])

// O(n) O(1)
// 执行用时：
// 56 ms, 在所有 JavaScript 提交中击败了 97.22% 的用户
// 内存消耗：
// 44.3 MB, 在所有 JavaScript 提交中击败了 55.56% 的用户
const maximumSum = arr => {
  let dp0 = arr[0];
  let dp1 = 0;
  let res = dp0;
  const n = arr.length;
  for (let i = 1; i < n; i++) {
    dp1 = Math.max(dp1 + arr[i], dp0);
    dp0 = Math.max(dp0, 0) + arr[i];
    res = Math.max(res, Math.max(dp0, dp1));
  }
  return res;
};

const arr = [1, -2, 0, 3];

console.log(maximumSum(arr));
