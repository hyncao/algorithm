// 1222. 可以攻击国王的皇后

// 在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。

// 给定一个由整数坐标组成的数组 queens ，表示黑皇后的位置；以及一对坐标 king ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。

// 输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
// 输出：[[0,1],[1,0],[3,3]]
// 解释：
// [0,1] 的皇后可以攻击到国王，因为他们在同一行上。
// [1,0] 的皇后可以攻击到国王，因为他们在同一列上。
// [3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。
// [0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。
// [4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。
// [2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。

// 输入：queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
// 输出：[[2,2],[3,4],[4,4]]

// 输入：queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
// 输出：[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]

// 思考：皇后的移动方式为横，竖，以及对角线，皇后和国王之间如果有棋子挡住则不能攻击
// 以国王为中心，朝8个方向辐射出去，看看是否能找到皇后即可

// 除了处理 Set 之外，其他时间复杂度都是常数级别，最差情况是 8 * 8
// O(n) O(n)
// 执行用时：
// 64 ms, 在所有 JavaScript 提交中击败了 69.70% 的用户
// 内存消耗：
// 43.1 MB, 在所有 JavaScript 提交中击败了 18.80% 的用户
const queensAttacktheKing = (queens, king) => {
  // 所有的移动方式
  const move = [
    [-1, -1],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 1],
    [-1, 0],
  ];
  const res = [];
  const queen = new Set();
  for (const i of queens) {
    queen.add(`${i[0]}${i[1]}`);
  }
  for (let moveIndex = 0; moveIndex < 8; moveIndex++) {
    const [yDelta, xDelta] = move[moveIndex];
    let [y, x] = king;
    x += xDelta;
    y += yDelta;
    while (x >= 0 && x < 8 && y >= 0 && y < 8) {
      if (queen.has(`${y}${x}`)) {
        res.push([y, x]);
        break;
      }
      x += xDelta;
      y += yDelta;
    }
  }
  return res;
};

const queens = [
    [0, 1],
    [1, 0],
    [4, 0],
    [0, 4],
    [3, 3],
    [2, 4],
  ],
  king = [0, 0];

console.log(JSON.stringify(queensAttacktheKing(queens, king)));
