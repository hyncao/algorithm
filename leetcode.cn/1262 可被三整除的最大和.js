// 1262. 可被三整除的最大和
// 给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。

// 输入：nums = [3,6,5,1,8]
// 输出：18
// 解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。

// 输入：nums = [4]
// 输出：0
// 解释：4 不能被 3 整除，所以无法选出数字，返回 0。

// 输入：nums = [1,2,3,4,4]
// 输出：12

// 思考：
// nums = [1,2,3,4,4]
// 先排序
// dp[n] 表示前 n 项的结果
// dp[0] = 0
// dp[1] = 0
// dp[2] = 3;
// dp[n] = dp[n-1] + Math.max(余数1 - 已选数组中最小的余数1, 余数2 - 已选数组中最小的余数2，余数2 - 已选数组中最小的两个余数1)
// 不行，因为还要考虑没选中的数

// 如果是从 sum 中减去不合格的数呢？
// 找到最小的余数1，和最小的余数2
// 因为 sum 要么是余数1，要么是余数2，要么就直接能被3整除
// 理论上来说最多只需要扔掉一个数就行了

// ！！！有问题！！！
// nums = [2, 6, 2, 2, 7]
// sum = 19
// min1 = 7
// min2 = 2
// sum - 7 < sum - 2 - 2
// 正确答案应该是 15 而不是 12
// 所以我们要维护两组最小数

// O(n) O(1)
// 执行用时：
// 68 ms, 在所有 JavaScript 提交中击败了97.87%的用户
// 内存消耗：
// 43.7 MB, 在所有 JavaScript 提交中击败了 85.11% 的用户
const maxSumDivThree = nums => {
  let min11 = Number.MAX_SAFE_INTEGER;
  let min12 = Number.MAX_SAFE_INTEGER;
  let min21 = Number.MAX_SAFE_INTEGER;
  let min22 = Number.MAX_SAFE_INTEGER;
  let sum = 0;
  for (const i of nums) {
    sum += i;
    if (i % 3 === 1) {
      if (i < min12) {
        min12 = i;
      }
      if (i < min11) {
        min12 = min11;
        min11 = i;
      }
    }
    if (i % 3 === 2) {
      if (i < min22) {
        min22 = i;
      }
      if (i < min21) {
        min22 = min21;
        min21 = i;
      }
    }
  }
  if (sum % 3 === 1) sum -= Math.min(min11, min21 + min22);
  if (sum % 3 === 2) sum -= Math.min(min21, min11 + min12);
  return sum;
};

const nums = [
  778, 668, 398, 81, 613, 888, 677, 608, 320, 616, 291, 347, 459, 686, 341, 901, 722, 932, 640, 700, 507, 782, 310, 551,
  361, 531, 309, 815, 516, 505, 67, 33, 863, 288, 352, 346, 226, 639, 592, 475, 638, 511, 639, 173, 960, 955, 726, 518,
  307, 195, 435, 88, 790, 74, 552, 606, 821, 887, 167, 558, 185, 932, 634, 318, 778, 771, 412, 443, 656, 801, 556, 48,
  795, 955, 626, 658, 801, 61, 667, 476, 855, 886, 216, 610, 484, 197, 752, 934, 412, 921, 592, 16, 43, 861, 37, 83,
  363, 151, 127, 746,
];

console.log(maxSumDivThree(nums));
