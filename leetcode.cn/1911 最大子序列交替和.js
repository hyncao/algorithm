// 1911. 最大子序列交替和

// 一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。

// 比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
// 给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。

// 一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。

// 输入：nums = [4,2,5,3]
// 输出：7
// 解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。

// 输入：nums = [5,6,7,8]
// 输出：8
// 解释：最优子序列为 [8] ，交替和为 8 。

// 输入：nums = [6,2,1,2,4,5]
// 输出：10

// 思考：
// 截止 2023-07-13 最难的 dp 题
// dp[i][0] 代表选择的最后一项的下标为 偶数 组成的子序列
// dp[i][1] 代表选择的最后一项的下标为 奇数 组成的子序列

// dp[i][0]
// 选择 nums[i]
// dp[i][0] = dp[i-1][1] + nums[i]
// 不选择 nums[i]
// dp[i][0] = dp[i-1][0]

// dp[i][1]
// 选择 nums[i]
// dp[i][1] = dp[i-1][0] - nums[i]
// 不选择 nums[i]
// dp[i][1] = dp[i-1][1]

// 最后的结果其实可以 Math.max(dp[i][0], dp[i][1])，但是 dp[i][0] 一定大于 dp[i][1]
// 因为 dp[i][1] 要做一次减法

// O(n) O(1)
// 执行用时：
// 76 ms, 在所有 JavaScript 提交中击败了 100.00% 的用户
// 内存消耗：
// 52.7 MB, 在所有 JavaScript 提交中击败了 23.81% 的用户
const maxAlternatingSum = nums => {
  let dp0 = 0;
  let dp1 = nums[0];
  const n = nums.length;
  for (let i = 1; i < n; i++) {
    // 注意：这里两行的执行顺序可以颠倒，不会出现先更新 dp1 影响到 dp0
    // 原因：如果 dp1 发生更新，那么 dp1 = dp0 + nums[i]
    // dp0 = Math.max(dp0, dp0 + nums[i] - nums[i])
    // dp0 = Math.max(dp0, dp0)
    dp1 = Math.max(dp1, dp0 + nums[i]);
    dp0 = Math.max(dp0, dp1 - nums[i]);
  }
  return dp1;
};

// 期望 370
const nums = [12, 58, 4, 48, 65, 45, 25, 61, 52, 15, 87, 51, 32, 19, 64, 97, 8, 4, 69, 10];

console.log(maxAlternatingSum(nums));
